{
  "version": 3,
  "sources": ["deno:file:///home/stagas/work/stagas/webaudio-webcomponents/framework/dom.ts", "deno:file:///home/stagas/work/stagas/webaudio-webcomponents/framework/util.ts", "deno:file:///home/stagas/work/stagas/webaudio-webcomponents/framework/state.ts", "deno:file:///home/stagas/work/stagas/webaudio-webcomponents/framework/index.ts"],
  "sourcesContent": ["// deno-lint-ignore-file no-explicit-any no-extra-semi\n\nconst { SHOW_DOCUMENT_FRAGMENT, SHOW_ELEMENT, SHOW_TEXT } = NodeFilter\nconst whitespaceTagNames = ['PRE', 'TEXTAREA']\n\nconst map = new WeakMap()\n\nexport const trim = (html: string) =>\n  html.trim().replace(/(>)(\\s+)|(\\s+)(<\\/)/g, '$1$4')\n\nexport function parse(html: string, context: any = {}) {\n  const el = document.createElement('div')\n\n  el.innerHTML = html\n\n  const fragment = document.createDocumentFragment()\n  while (el.hasChildNodes()) fragment.appendChild(el.firstChild as HTMLElement)\n\n  const tree = document.createTreeWalker(\n    fragment,\n    SHOW_DOCUMENT_FRAGMENT | SHOW_ELEMENT | SHOW_TEXT,\n    null,\n    false,\n  )\n\n  const root: any = { tag: 'div', attrs: {}, children: [], context }\n\n  while (tree.nextNode()) {\n    const node = tree.currentNode\n    const parent = map.get(node.parentNode as HTMLElement)\n\n    let v: any\n\n    if (node.nodeType === Node.TEXT_NODE) {\n      v =\n        context.trim\n          && !whitespaceTagNames.includes(\n            (node.parentNode as HTMLElement)?.tagName,\n          )\n          ? trim(node.textContent ?? '')\n          : node.textContent\n    }\n    else {\n      v = {\n        tag: (node as HTMLElement).tagName,\n        ...attrs(node),\n        children: [],\n        context,\n      }\n\n      for (const name in v.events) {\n        const fn = new Function(\n          'event',\n          'context',\n          `with (context) { ${v.events[name]} }`,\n        )\n        v.events[name] = function(event: Event) {\n          return fn.call(this, event, v.context)\n        }\n      }\n    }\n\n    map.set(node, v)\n\n    if (parent) parent.children.push(v)\n    else root.children.push(v)\n  }\n\n  return root\n}\n\nconst attrs = (node: any) =>\n  [...node.attributes].reduce(\n    (\n      p,\n      n,\n    ) => (p[['attrs', 'events'][+(n.name.indexOf('on') === 0)]][n.name] =\n      n.value,\n      p),\n    { attrs: {}, events: {} },\n  )\n\nconst update = (node: any, v: any, parent: any, updated = v.updated) => {\n  if (!v.tag) {\n    return node.data !== v && (parent.updated = true) && (node.data = v)\n  }\n\n  for (const name in v.events) {\n    node[name] = v.events[name], updated = true\n  }\n\n  for (const name in v.attrs) {\n    if (node.getAttribute(name) !== v.attrs[name] && (updated = true)) {\n      node.setAttribute(name, v.attrs[name])\n    }\n  }\n\n  for (const { name } of [...node.attributes]) {\n    if (!(name in v.attrs) && (updated = true)) {\n      node.removeAttribute(name)\n    }\n  }\n\n  return v.updated = updated\n}\n\nconst create = (v: any) =>\n  v.tag && (v.rendered = true)\n    ? document.createElement(v.tag)\n    : document.createTextNode(v)\n\nexport function render(currentNode: any, v: any) {\n  const prev = currentNode.childNodes\n  const next = v.children\n\n  while (prev.length > next.length) {\n    currentNode.removeChild(currentNode.lastChild)\n  }\n\n  for (const [i, child] of next.entries()) {\n    let node = prev[i]\n\n    if (!node) {\n      currentNode.appendChild(node = create(child))\n    }\n    else if (node.tagName !== child.tag) {\n      currentNode.replaceChild(node = create(child), prev[i])\n    }\n\n    update(node, child, v)\n\n    if (child.children) render(node, child)\n  }\n\n  if (v.updated) dispatch(currentNode, 'onupdate')\n  if (v.rendered) dispatch(currentNode, 'onrender')\n}\n\nconst dispatch = (node: any, event: string, fn = node.tagName && node[event]) =>\n  fn && fn.call(node)\n\nexport function dom(parent: any, html: string, context: any) {\n  render(parent, parse(html, context))\n}\n", "// deno-lint-ignore-file no-explicit-any no-extra-semi\n\nimport { effect } from './state.ts'\n\nexport const top: any = window\ntop.__methods__ ??= new Map()\ntop.__currentObject__ ??= null\n\nexport const UID = (key?: string) => {\n  return (key ? key + '_' : '') + (Math.random() * 10e6 | 0).toString(36)\n}\n\nexport const patchMethod = (obj: any, method: any, key?: string) => {\n  const uid = UID(key)\n  top.__methods__.set(uid, method.bind(obj))\n  method.toString = () => `__methods__.get('${uid}')`\n  return method\n}\n\nexport const patchMethods = (obj: any, methods: Record<string, any>) => {\n  for (const [key, method] of Object.entries(methods)) {\n    if (typeof method !== 'function') continue\n    patchMethod(obj, method, key)\n  }\n  return methods\n}\n\nexport const bind = (obj: any) =>\n  (parts: string[], ...values: any[]) => {\n    let str = ''\n    for (let i = 0; i < parts.length; i++) {\n      str += parts[i]\n      const value = values[i]\n      if (typeof value === 'function') {\n        str += patchMethod(obj ?? top.__currentObject__, value).toString()\n      }\n      else if (value) {\n        str += value\n      }\n    }\n    return str\n  }\n\nexport const el = (tagName: string, content: any) => {\n  const uid = UID('x')\n  const str = `<${tagName} id=\"${uid}\"></${tagName.split(' ')[0]}>`\n  const obj = top.__currentObject__\n  effect(() => {\n    const domEl = obj.get('#' + uid)\n    if (domEl) {\n      domEl.textContent = content.value\n    }\n  }, content)\n  return str\n}\n\nconst { SHOW_DOCUMENT_FRAGMENT, SHOW_ELEMENT, SHOW_TEXT } = NodeFilter\n\nexport function* traverse(node: Node | null) {\n  if (node) {\n    const tree = document.createTreeWalker(\n      node,\n      SHOW_DOCUMENT_FRAGMENT | SHOW_ELEMENT | SHOW_TEXT,\n      null,\n      false,\n    )\n\n    // deno-lint-ignore no-cond-assign\n    while (node = tree.nextNode()) {\n      yield node\n    }\n  }\n}\n\nexport const flatten = (node: Node | null) => {\n  return [...traverse(node)]\n}\n", "// deno-lint-ignore-file no-explicit-any no-extra-semi\n\nimport { patchMethod, top } from './util.ts'\n\nexport type Constructor =\n  | ArrayConstructor\n  | ObjectConstructor\n  | StringConstructor\n  | NumberConstructor\n  | BooleanConstructor\n  | FunctionConstructor\n\nexport type StateTypes = Record<string, Constructor>\n\nexport const Types: StateTypes = {\n  array: Array,\n  object: Object,\n  string: String,\n  number: Number,\n  boolean: Boolean,\n  function: Function,\n}\n\nconst getType = (value: any) => {\n  return Array.isArray(value) ? Types.array : Types[typeof value]\n}\n\nconst getDefaultValue = (value: any) => {\n  // dprint-ignore\n  return value === Boolean  ? false\n       : value === Array    ? []\n       : value === Function ? () => {}\n       : value === String   ? ''\n       : null\n}\n\nconst castTo = (type: any, value: any) => {\n  // dprint-ignore\n  return type === Boolean && value === ''                 ? true\n       : type === Array    ? (Array.isArray(value)        ? value.slice() : [])\n       : type === Function ? (typeof value === 'function' ? value : () => {})\n       : type(value)\n}\n\nconst proxies = new WeakMap()\n\nlet _unwrap = false\nlet _quiet = false\n\nexport const quiet = (fn: () => void) => {\n  const prevQuiet = _quiet\n  _quiet = true\n  try {\n    fn()\n  }\n  catch (e) {\n    console.error(e)\n  }\n  _quiet = prevQuiet\n}\n\ntype StateDescription = Record<string, any>\n\nexport const state = (desc: StateDescription = {}) => {\n  const target: Record<string, any> = {}\n  const types = new Map()\n  const props = new Map()\n  const resolved = new Set()\n\n  for (const [prop, value] of Object.entries(desc)) {\n    if (Object.values(Types).includes(value)) {\n      types.set(prop, value)\n      target[prop] = getDefaultValue(value)\n    }\n    else {\n      types.set(prop, getType(value))\n      target[prop] = value\n      resolved.add(prop)\n    }\n    props.set(prop, new Set())\n  }\n\n  const proxy = new Proxy(target, {\n    get(target, prop, proxy) {\n      if (_unwrap) return Reflect.get(target, prop)\n      else {\n        return {\n          name: prop,\n          proxy,\n          subscribe(fn: () => void) {\n            props.get(prop).add(fn)\n          },\n          unsubscribe(fn: () => void) {\n            props.get(prop).delete(fn)\n          },\n          get hasResolved() {\n            return resolved.has(prop)\n          },\n          get value() {\n            return this.valueOf()\n          },\n          [Symbol.toPrimitive]() {\n            return this.valueOf()\n          },\n          valueOf() {\n            return Reflect.get(target, prop)\n          },\n        }\n      }\n    },\n\n    set(target, prop, value) {\n      // if (_quiet) {\n      //   return Reflect.set(target, prop, value)\n      // }\n      const type = types.get(prop)\n\n      if (!type) {\n        throw new ReferenceError('State has no property: ' + prop.toString())\n      }\n\n      const valueToSet = castTo(type, value)\n\n      // if value is the same as before, don't trigger\n      if (valueToSet === Reflect.get(target, prop)) {\n        return true\n      }\n\n      const result = Reflect.set(target, prop, valueToSet)\n\n      if (result) {\n        resolved.add(prop)\n\n        // TODO: microtask fn triggers\n        props.get(prop).forEach((fn: () => void) =>\n          triggerIfSatisfied(fn, prop)\n        )\n      }\n\n      return result\n    },\n\n    ownKeys(target) {\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  proxies.set(proxy, { target, props, types, resolved })\n\n  return proxy\n}\n\nconst unwrapFactory = (flag: boolean) =>\n  (fn: () => void) => {\n    const prevUnwrap = _unwrap\n    _unwrap = flag\n    try {\n      fn()\n    }\n    catch (e) {\n      console.error(e)\n    }\n    _unwrap = prevUnwrap\n  }\n\nexport const unwrap = unwrapFactory(true)\nexport const wrap = unwrapFactory(false)\n\nconst effects = new WeakMap()\nconst once = new WeakSet()\n\nconst triggerIfSatisfied = (fn: () => void, _prop?: string | symbol) => {\n  const deps = [...effects.get(fn)]\n  const didUpdate = deps.every((prop) => prop.hasResolved)\n  if (didUpdate) {\n    top.__currentObject__ = contexts.get(fn)\n    unwrap(fn)\n    if (once.has(fn)) {\n      once.delete(fn)\n      deps.forEach((dep) => dep.unsubscribe(fn))\n      effects.delete(fn)\n    }\n  }\n}\n\nconst contexts = new WeakMap()\n\nexport const effect = (fn: () => void, ...deps: any[]) => {\n  deps = deps.filter(Boolean)\n  contexts.set(fn, top.__currentObject__)\n  effects.set(fn, new Set(deps))\n  try {\n    wrap(() => deps.forEach((dep) => dep.subscribe(fn)))\n    triggerIfSatisfied(fn)\n  }\n  catch (e) {\n    console.trace(deps)\n    console.error(e)\n  }\n  return () => {\n    once.delete(fn)\n    wrap(() => deps.forEach((dep) => dep.unsubscribe(fn)))\n    effects.delete(fn)\n  }\n}\n\neffect.once = (fn: () => void, ...deps: any[]) => {\n  once.add(fn)\n  return effect(fn, ...deps)\n}\n\neffect.wrap = (fn: () => void, ...deps: any[]) => {\n  return effect(wrap(fn) as any, ...deps)\n}\n\nexport const callback = (fn: (...args: any[]) => void, obj: any) => {\n  const callbackFn = (...args: any[]) => {\n    let result\n    unwrap(() => {\n      result = fn(...args)\n    })\n    return result\n  }\n  if (obj) {\n    patchMethod(obj, callbackFn)\n  }\n  return callbackFn\n}\n\ntype Task = { fn: (...args: any[]) => Promise<void>; args: any[] }\n\nexport const atomic = (fn: (...args: any[]) => Promise<void>) => {\n  let next: Task | null\n  let task: Task | null\n  let promise: Promise<void> | null\n\n  const run = async (): Promise<void> => {\n    if (task) await promise\n    task = next\n\n    next = null\n\n    if (task) {\n      try {\n        promise = task.fn(...task.args)\n        await promise\n      }\n      catch (e) {\n        console.error(e)\n      }\n      finally {\n        task = null\n      }\n    }\n\n    if (next) return run()\n  }\n\n  return (...args: any[]) => {\n    const hadNext = next\n    next = { fn, args }\n    if (!hadNext) {\n      return run()\n    }\n    else {\n      return promise\n    }\n  }\n}\n", "// deno-lint-ignore-file no-explicit-any no-extra-semi\n\nimport { dom } from './dom.ts'\nimport { effect, quiet, state, Types, unwrap, wrap } from './state.ts'\nimport { bind, flatten, patchMethods, top } from './util.ts'\n\nexport * from './state.ts'\nexport * from './util.ts'\n\ntype ComponentDescriptor = {\n  class: string\n  extends: typeof Base\n  slot: boolean\n} & ComponentParams\n\nconst ComponentDescriptorProperties = [\n  'class',\n  'extends',\n  'slot',\n  'attrs',\n  'props',\n  'pins',\n  'component',\n]\n\nconst arrayEqual = (a: any[], b: any[]) => a.every((x, i) => x === b[i])\n\nconst pascalCase = (s: string) =>\n  s.split('-').map((p: string) => p[0].toLocaleUpperCase() + p.slice(1)).join(\n    '',\n  )\n\nconst mergeFilter = (\n  target: Record<string, any>,\n  source: Record<string, any>,\n  fn: (key: string, value: any) => boolean,\n) => {\n  for (const [key, value] of Object.entries(source)) {\n    if (fn(key, value)) target[key] = value\n  }\n  return target\n}\n\n// deno-lint-ignore valid-typeof\nconst is = (type: any, item: any) => typeof item === type\nconst isType = (item: any) => Object.values(Types).includes(item)\nconst isProp = (key: string) => ComponentDescriptorProperties.includes(key)\n\nconst getLocalProperties = (d: ComponentDescriptor) =>\n  mergeFilter({}, d, (k, v) => !is('function', v) && !isProp(k))\nconst getPrototypeMethods = (d: ComponentDescriptor) =>\n  mergeFilter({}, d, (k, v) => is('function', v) && !isProp(k))\n\nconst copy = (target: Record<string, any>, source: Record<string, any>) => {\n  for (const [key, value] of Object.entries(source)) {\n    if (Array.isArray(value)) {\n      target[key] = value.slice()\n    }\n    else if (typeof value === 'object') {\n      target[key] = Object.create(value)\n    }\n    else {\n      target[key] = value\n    }\n  }\n}\n\nexport const mergeParams = (target: any = {}, source: any = {}) => {\n  for (const [key, value] of Object.entries(source)) {\n    if (Array.isArray(value)) {\n      target[key] = value.slice()\n    }\n    else if (typeof value === 'object') {\n      target[key] = mergeParams(target[key] || {}, value)\n    }\n    else {\n      target[key] = value\n    }\n  }\n  return target\n}\n\nconst createAccessors = (\n  target: any,\n  source: any = {},\n  accessors: any = {},\n) => {\n  for (const key in source) {\n    // save the instance value\n    const value = target[key]\n    Object.defineProperty(target, key, {\n      get() {\n        return accessors.get?.call(this, key) ?? Reflect.get(source, key)\n      },\n      set(value: any) {\n        accessors.set?.call(this, key, value)\n        return Reflect.set(source, key, value)\n      },\n    })\n    // re-apply value to trigger setter\n    if (value != null) target[key] = value\n  }\n}\n\nclass Base extends HTMLElement {\n  static slot: boolean\n  static observedAttributes: string[]\n\n  html!: string\n  slotted!: Node[]\n  params: ComponentParams\n  state: ComponentParams\n\n  constructor({ attrs = {}, props = {}, pins = {} }: ComponentParams = {}) {\n    super()\n\n    const self = this as any\n    const ctor = this.constructor as typeof Base\n\n    const params: ComponentParams = mergeParams({ attrs, props, pins }, {\n      props: { slotted: Array, html: String },\n    })\n\n    this.params = params\n\n    this.state ??= {\n      attrs: state(params.attrs),\n      props: state(params.props),\n      pins: state(\n        Object.fromEntries(\n          Object.keys(params.pins ?? {}).map(key => [key, Object]),\n        ),\n      ),\n    }\n\n    createAccessors(this, this.state.props)\n    createAccessors(this, this.state.attrs, {\n      set(key: string, value: any) {\n        if (this.getAttribute(key) != value) {\n          // this will trigger the observed attributes\n          // and this function will run again, so we\n          // return and let the observed fn to proceed\n          this.setAttribute(key, value)\n          return\n        }\n      },\n    })\n    createAccessors(this, this.state.pins)\n\n    if (ctor.slot) this.createSlot()\n\n    effect(() => {\n      this.root.innerHTML = this.html\n\n      for (const [key, selector] of Object.entries(params.pins ?? {})) {\n        self[key] = this.get(selector as string)\n      }\n\n      const slot = this.root.querySelector('slot')\n      if (slot) {\n        this.useSlot(slot)\n      }\n    }, this.html)\n  }\n\n  get root() {\n    if (!this.shadowRoot) this.attachShadow({ mode: 'open' })\n    return this.shadowRoot as ShadowRoot\n  }\n\n  render(parts: string[], ...values: any[]) {\n    dom(this.root, bind(this)(parts, ...values), this)\n\n    for (const [key, selector] of Object.entries(this.params.pins ?? {})) {\n      ;(this as any)[key] = this.get(selector as string)\n    }\n\n    const slot = this.root.querySelector('slot')\n    if (slot) {\n      this.useSlot(slot)\n    }\n  }\n\n  useSlot(slot: HTMLSlotElement) {\n    const elements = () =>\n      slot.assignedElements({ flatten: true }).slice().map(el =>\n        [el, flatten(el)].flat()\n      ).flat()\n\n    if (slot.parentNode !== this.root) {\n      this.root.appendChild(slot)\n    }\n    const get = () => {\n      const newElements = elements()\n      if (newElements.length) {\n        this.slotted = newElements\n      }\n    }\n    get()\n    slot.addEventListener('slotchange', get)\n  }\n\n  createSlot() {\n    const slot = document.createElement('slot')\n    this.useSlot(slot)\n  }\n\n  get(selector: string) {\n    return this?.shadowRoot?.querySelector?.(selector)\n  }\n\n  getSlot(selector: string) {\n    return this?.shadowRoot?.querySelector?.('slot')?.querySelector(selector)\n  }\n\n  getAll(selector: string) {\n    return this?.shadowRoot?.querySelectorAll?.(selector)\n  }\n\n  getAllSlot(selector: string) {\n    return this?.shadowRoot?.querySelector?.('slot')?.querySelectorAll(selector)\n  }\n\n  dispatch(name: string, payload: any) {\n    this.dispatchEvent(\n      new CustomEvent(name, { bubbles: true, composed: true, detail: payload }),\n    )\n  }\n\n  attributeChangedCallback(\n    this: any,\n    name: string,\n    _oldValue: any,\n    newValue: any,\n  ) {\n    wrap(() => {\n      this[name] = newValue\n    })\n  }\n}\n\ntype ComponentParams = {\n  component?: () => void\n  attrs?: Record<string, any>\n  props?: Record<string, any>\n  pins?: Record<string, string>\n}\n\nexport const create = (d: ComponentDescriptor) => {\n  const { component = () => {}, attrs = {}, props = {}, pins = {} } = d\n  const Parent = d.extends ?? Base\n  const className = pascalCase(d.class)\n  const Component = {\n    [className]: class extends Parent {\n      constructor(params: ComponentParams) {\n        super(mergeParams(params, { attrs, props, pins }))\n        top.__currentObject__ = this\n        patchMethods(this, getPrototypeMethods(d))\n        copy(this, getLocalProperties(d))\n        component?.call(this)\n      }\n    },\n  }\n\n  Object.assign(Component[className], { slot: Parent.slot || d.slot, desc: d })\n  Object.assign(Component[className].prototype, getPrototypeMethods(d))\n  Object.defineProperty(Component[className], 'observedAttributes', {\n    get() {\n      return Object.keys(d.attrs ?? []).concat(\n        (Parent ?? {}).observedAttributes || [],\n      )\n    },\n  })\n\n  return Component[className]\n}\n"],
  "mappings": "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",
  "names": []
}
